<plain_text><page sequence="1">Three Models of Computer Software Alan Cooper Cooper Software, Inc. Editor's Note: The following is the first in an occasional series of reprints of or excerpts from landmark works on technical communication or related topics. Alan Cooper's reflections here on the way we think about technology and the language we use to express those thoughts are meaningful to communicators of any technology, not just to software interface designers. People in the computer industry frequently toss around the term "computer literacy." They talk about how some people have it and some don't; about how those who have it will succeed in the information age and those who lack it will fall between the social and economic cracks of the new age. But computer literacy is nothing more than a euphemism for making the user stretch to reach an information age appliance rather than having the appliance stretch to meet the user. The manifest model Any given machine has a method for accomplishing its purpose. A motion picture projector, for example, uses a complicated sequence of intricately moving parts to create its illusion. It shines a very bright light through a translucent, From About Face: The Essentials of User Interface Design by Alan Cooper, published by IDG Books Worldwide, Inc. Copyright © 1995 by IDG Books Worldwide, Inc. All rights reserved. No part of this book (including interior design, cover design, and illustrations) may be reproduced or transmitted in any form, by any means, (electronic, photocopying, recording, or otherwise) without the prior written permission of the publisher. For authorization to photocopy items for internal corporate use, personal use, or educational and /or classroom use, please contact Copyright Clearance Center, 222 Rosewood Drive, Danvers, MA 01923 USA, Fax 508-750-4470. miniature image for a fraction of a second. It then blocks out the light for a split second while it moves another miniature image into place. Then it unblocks the light again for another moment. It repeats this process with a new image 24 times per second. The actual method of how a device works is what I call its implementation model. From the movie-goer's point of view, it is easy to forget the nuance of sprocket holes and light- interrupters while watching an absorbing drama. The viewer imagines that the projector merely throws onto the big screen a picture that moves. This is what is called the user's mental model, or sometimes his or her conceptual model. People don't need to know all of the details of how some complex process actually works to use it, so they create a mental shorthand for explaining it, one that is powerful enough to cover all instances, but that is simple and easy. For example, many people imagine that when they plug their vacuums and blenders into outlets in the wall, electricity travels up to them through little black tubes. This mental model is perfectly adequate for using all household appliances. The fact that the implementation model of household electricity involves nothing actually travelling up the cord or that there is a reversal of electrical potential 120 times per second is irrelevant to the user, although the power company needs to know these details. Technical Communication, Third Quarter 1996 229</page><page sequence="2">£ßÖÖO Implementation WorSB B©ttßr Mental Model Model reflects * Closer to Implementation Closer to Mental &gt; reflects user's technology Moļje| Motļe| vision Manifest Models Figure 1. The way the engineer must build the program is usually a given . We call this the implementation model. The way users perceive the program is usually beyond our control. They will conjure up a likely image that we call the mental model. The way the designer chooses to render the program we call the manifest model; this is the one aspect of the program that we can change significantly. If we use logic and reason to make the manifest model follow reality - the implementation model - shown on the left, we will create a bad interface. On the other hand, if we abandon logic and make the manifest model follow the useťs imagination - the mental model - shown on the right , we will create a good interface. In the digital world, however, the differences between a user's mental model and an actual implementation model may be stretched far apart. We ignore the fact that a cellular telephone might swap connections between a dozen different cell antennas in the course of a 2-minute phone call. Knowing this doesn't help us to understand how to work our car phones. This is particularly true for computer software, where the complexity of implementation can make it nearly impossible for users to see the connections between their actions and the program's reaction. When we use the computer to digitally edit sound or display video effects like morphing, we are bereft of analogy to the mechanical world, so our mental models are necessarily different from the implementation model. Even if the connections were visible, they would remain inscrutable. Computer software has a behavioral face it shows to the world, one made up by the programmer or designer. This posture is not necessarily an honest representation of what is really going on inside the computer, although it frequently is. This ability to represent the computer's functioning independent of its true actions is far more pronounced in software than in any other medium. It allows a clever designer to hide some of the more unsavory facts of how the software is really getting the job done. This disconnection between what is real and what is offered as explanation gives rise to a third model in the digital world, which I call the manifest model. It is the way the program represents its functioning to the user. In the world of software, a program's manifest model can be quite divergent from the actual processing structure of the program. For example, an operating system can make a network file server look as though it were a local disk. The fact that the physical disk drive may be miles away is not made manifest by the model. This concept of the manifest model has no widespread counterpart in the mechanical world. The relationship between the three models is shown in Figure 1. Although software developers have absolute control over a program's manifest model, considerations of efficiency will strongly dictate their choice. Designers, on the other hand, have considerable leeway in their choice of manifest model. The closer our manifest model comes to the users' mental model, the easier they will find the program to use and to understand. Generally, offering a manifest model that closely follows the implementation model will reduce the users' ability to use and learn the program. We tend to form mental models that are simpler than reality, so creating manifest models that are simpler than the actual implementation model can help the user achieve a better understanding. Pressing the brake pedal in your car, for example, may conjure a mental image of pushing a lever that rubs against the wheels to slow you down. The actual mechanism includes hydraulic cylinders, tubing and metal pads that squeeze on a perforated disk, but we simplify all of that in our minds, creating a more effective, albeit less accurate, mental model. In software, we imagine that a spreadsheet "scrolls" new cells into view when 230 Technical Communication, Third Quarter 1996</page><page sequence="3">we click on the scrollbar. Nothing of the sort actually happens. There is no sheet of cells out there, but a tightly packed heap of cells with various pointers between them, and the program synthesizes a new image from them to display in real-time. The ability to tailor the manifest model is a powerful lever that the software designer can use positively or negatively. If the manifest model takes the trouble to closely represent the implementation model, the user can get confused by useless facts. Conversely, if the manifest model closely follows a likely mental model, it can take much of the complexity out of a user interface. When we interact with computer software, we tend to create anthropomorphic mental models. My program "reads" what I type in and "answers" me back with an appropriate response. It doesn't really do anything of the sort, but this mental model is still a very effective tool to manage the complexity of a system. If the software manifests this same anthropomorphic model, it will be easier for the user to relate to. Even hard-core propeller-heads anthropomorphize computers to better understand them. This mental model isn't "real," but it is analogically and symbolically valid, and very practical. Programmers often curse at their recalcitrant computers, even though they know they aren't listening. We do this partly because our bodies have a mechanical structure. Our limbs, hands and fingers are levers, so we think of automobile suspension systems as arms or ankles, even though they are much more complex than that. Even hard-core propeller-heads anthropomorphize computers in order to better understand them. This mental model isn't " real " but it is analogically and symbolically valid, and very practical. A mental model doesn't necessarily have to be true or accurate, but it enables the user to work effectively with the modeled process. For example, most non-technical computer users imagine that their video screen is the heart of their computer. This is only natural because the screen is what they stare at all the time and is the place where they see what the computer is doing. If you point out that the computer is actually a little chip of silicon in that big steel box sitting under their desk, they will probably shrug and ignore this pointless factoid. The fact that the CPU isn't actually in the video display doesn't help them think about how they work with their computer, even though it is a more technically accurate concept. The industry doesn't invest a lot of effort in disabusing people of this mental model because it so clearly helps and it doesn't seem to get in anybody's way. Most software conforms to IMPLEMENTATION MODELS Because software interfaces are often designed by engineers who know exactly how the software works, the result is software with a manifest model very consistent with its implementation model. This is logical and truthful, but not very effective. The user doesn't care all that much about how a program is actually implemented. Of course, he cares about any problems that arise because of the difference between the models, but the difference itself is of no particular interest. There is a real communication gap between technical people who understand implementation models and non-technical users who think purely in terms of mental models. Any time users telephone a software company's technical support hotline, they will probably fall into that gap. Understanding how software actually works will always help someone to use it, but this understanding usually comes at a significant cost. The manifest model allows software creators to solve the problem by simplifying the apparent way the software works. The cost is entirely internal, and the user never has to know. User interfaces that abandon implementation models to follow mental models more closely are better. In Adobe PhotoShop the user can adjust the color balance of an illustration. A small dialog box, instead of offering a numeric setting- the implementation model - shows a series of small, sample images, each with a different color balance. The user can click on the image that best represents the desired color setting. Because the user is thinking in terms of color, not in terms of numbers, the dialog more closely follows his or her mental model. User interfaces that conform to implementation models are bad. A prime example of a user interface conforming to the implementation model instead of to the user's Technical Communication, Third Quarter 1996 231</page><page sequence="4">Figure 2. DeIrina9 s WinFax LITE is a great study in aggravating users. Even in an application as simple as this one, they can't seem to resist adding complications . For most people on this planet, there are only two options: selecting an existing number or entering a new one . They have to ask for both options explicitly, and both options force a secondary dialog . Even though you can add a new number to the phonebook in place, they force a completely extraneous dialog box on you just to make sure that any ease-of-use you might be experiencing is destroyed. mental model can be found in Delrina's WinFax LITE product. Every step of the process is agonizingly wrought in discrete steps that the user must laboriously control, and none of which are necessary from the user's point of view. The interaction with the user is rendered in perfect conformance with the internal logic of the software. Every possible user action is duly represented by a separate dialog box. You can see some of this in Figure 2. The user is prompted for information when it is convenient for the program to receive it - not when it is natural for the user to provide it. The manifest model of the WinFax program closely follows the implementation model and ignores the user's mental model. Instead of imagining the steps the user might take to create and send a fax, the designer imagined what the program had to do. This is typical of a user interface designed by programmers. When I want to send a fax, it will either be to a person whose name I haven't yet entered into the program or one I already have. The code that performs these functions is encased in separate modules inside the program, so the program encases these functions in separate dialog boxes. To either select or enter names, I have to sidestep the main program, even though selecting and entering names is the program's primary function. Similar logic in automobile design would have us manually setting the spark advance lever as we accelerated and manually flipping the brake light switch when we decelerated. Here's a better way to manage the WinFax problem: Whenever I enter a new fax name and number, the program should automatically record it. WinFax' s main window should display a list of the names of previous fax recipients, allowing me to quickly choose one from the list if I want. Even Windows 95 misses this point. The Explorer attempts to show all of the storage devices on the computer as a unified system, but to successfully communicate that to the user, their behavior must also be unified. Instead, their behavior depends on the physical nature of the particular storage device. If you drag a file between directories on the same hard drive, the program interprets this as a MOVE, that is, the file is removed from the old directory and added to the new directory, closely following the mental model. However, if you drag a file from hard drive C to hard drive D, the action is interpreted as a copy; that is, the file is added to the new directory but not 232 Technical Communication, Third Quarter 1996</page><page sequence="5">removed from the old directory. This is consistent with the implementation model - the way the underlying file system actually works. When the operating system moves a file from one directory to another on the same drive, it merely relocates the file's entry in the disk's table of contents. It never actually erases and rewrites the file. But when it moves a file to another physical drive, it must physically copy the data onto the new drive. To conform to the user's mental model, it should then erase the original, even though that contradicts the implementation model. Microsoft's programmers evidently couldn't bring themselves to manifest it in any terms other than the physical ones. Actually, this behavior can be desirable, especially when copying files from a hard drive to a floppy drive, so many people aren't aware that it is just a terrifically inconsistent side effect. As computers mature and logical "volumes" represent more than just physical drives, the side effects stop being useful and become merely irritating because you have to memorize the idiosyncratic behavior. Mathematical thinking The interface designer must shield the user from the implementation models that the software engineer used to solve the internal problems of the software. Just because a certain tool is well-suited to attacking a problem in software construction doesn't necessarily mean that it is well-suited as a mental model for the user. In other words, just because your house is constructed of two-by-four studs and sixteen-penny nails, it doesn't mean that you should have to be skilled with a hammer to live there. The interface designer must shield the user from the implementation models that the software engineer used to solve the internal problems of the software. Most of the data structures and algorithms used to represent and manipulate information in software are logic tools based on mathematical models. All programmers are fluent in these models, including such things as recursion, hierarchical data structures and multi-threading. The problem arises when the user interface manifests the concepts of recursion, hierarchical data, or multi-threading. Mathematical thinking is an implementation model trap that is particularly easy for programmers to fall into. They solve programming problems by thinking mathematically, so they naturally see these mathematical models as appropriate terms for inventing user interfaces. Nothing could be further from the truth. Design tip: Users don't understand Boolean. For example, one of the most durable and useful tools in the programmer's toolbox is Boolean algebra. It is a compact mathematical system that conveniently describes the behavior of the strictly on-or-off universe that exists inside all digital computers. There are only two main operations: and and or. The problem is that the English language also has an "and" and an "or," and they are usually interpreted - by non-programmers - as the exact opposite of the Boolean and and or. If the program expresses itself with Boolean notation, the user can be expected to misinterpret it. For example, this problem crops up frequently when querying databases. If I want to extract from a file of employees those who live in Arizona along with those who live in Texas, I would say, in English, "get employees in Arizona and Texas." To say that properly in Boolean algebraic terms, I would say "get employees in Arizona or Texas." No employee lives in two states at once, so saying "get employees in Arizona and Texas" is nonsensical in Boolean and will always return the empty set as an answer. If you want to extract from that database all of the employees who started work between January 1st and February 28th, it seems natural to say, in English, "get employees with start dates of January and February." In Boolean, you would say "get employees with start dates of January or February." A database query program - or any other program, for that matter - that interacts with the user in Boolean is doomed to suffer severe user interface problems. It is unreasonable to expect users to penetrate the confusion. They are well-trained in English, so why should they have to express things in an unfamiliar language that - annoyingly - redefines key words. Bringing mechanical age models into THE INFORMATION AGE We are experiencing an incredible transformation from a mechanical age to an information age. The Technical Communication, Third Quarter 1996 233</page><page sequence="6">change has only begun, and the pace is accelerating rapidly. The upheaval that society underwent as a result of industrialization will be dwarfed by that associated with the information age. It is only natural for us to drag the imagery and taxonomy of the earlier era into the new one. As the history of the Industrial Revolution shows, the fruits of new technology can often only be expressed at first with the language of an earlier technology. For example, we called railroads "iron horses," automobiles "horseless carriages," and radio "wireless." Unfortunately, this imagery and taxonomy colors our thinking more than we might admit. As the history of the Industrial Revolution shows, the fruits of new technology can often only be expressed at first with the language of an earlier technology. Importing linguistic or mental images directly from the pre-digital world is an example of what I call mechanical age modeling. We use old representations in the new environment. Sometimes, the usage is valid since the function is identical, even if the underpinning technology is different. For example, when we translate the process of typewriting with a typewriter into word processing on a computer, we are doing mechanical-age modeling of a common task. Typewriters used little metal tabs to slew the carriage rapidly over several spaces and come to rest on a particular column. The process, as a natural outgrowth of the technology, was called "tabbing" or "setting tabs." Word processors also have tabs because their function is the same: whether you are working on paper rolled around a platen or on images on a video screen, you need to rapidly slew to a particular margin offset. Sometimes, however, the mechanical-age model can't make the cut into the digital world. We don't use reins to steer our cars, or even a tiller, although both of these older models were tried in the early days of autos. It took many years to develop an idiom that was unique to and appropriate for the car. When technology changes dramatically, we often find that the nature of the tasks we perform generates what I call information age models. These are tasks, processes, or concepts that arise solely because the new technology makes them possible for the first time. With no reason to exist in the non-digital version, they were not conceived of in advance. When the telephone was first invented, for example, it was touted solely as a business tool. Its use as a personal tool wasn't conceived of until it had been in use for 40 years. Today, of course, the phone is used at least as much for personal reasons as it is for business. When your teenage son spends an hour on the phone, it is a usage model that was invisible from the older world. New conceptual models are not exclusive to the digital world; they are part of any rapidly shifting context, and technology is our current context. Digital technology is the most rapidly shifting context humankind has witnessed so far, so new and surprising information-age models are and will be plentiful. An interesting thing about information-age models is that we have a hard time seeing them with our mechanical-age mindset. Often, the real advantages of the software products we create remain invisible until they have a sizable population of users. For example, the real advantage of e-mail isn't that it's faster mail, but rather the flattening and democratization that it promotes in the modern business organization - the information-age advantage. The real advantage of making it possible for everybody to communicate online isn't cheaper and more-efficient communications - the mechanical-age viewpoint. Instead, it is the creation of virtual communities - the information-age advantage that was revealed only after it materialized in our grasp. The real advantage of making it possible for everybody to communicate online isnyt cheaper and more-efficient communications - the mechanical-age viewpoint. Instead, it is the creation of virtual communities - the information-age advantage that was revealed only after it materialized in our grasp. The language we bring to the new environment creates a problem because it is always derived from mechanical-age models. Forty years ago, the computer was envisioned as a big collating machine, and we applied the collation model to it. We saw it as a "unit-record" device for 80-column-wide keypunch cards. Today, when computers are ubiquitous 234 Technical Communication, Third Quarter 1996</page><page sequence="7">personal productivity machines, we still find vestigial indications of that 80-column, unit-record world. The taxonomy of the mechanical-age model tends to obscure the recognition of information-age models. The mechanical taxonomy hinders invention and goal-directed design by focusing our thinking on old- paradigm goals. For example, in the non-digital world calendars are made of páper and are usually divided up into a 1-month-per-page format. This is a reasonable compromise based on the size of paper, file folders, briefcases and desk drawers. Now that we have desktop computers, we frequently see programs with graphic representations of calendars, and they almost always show 1 month at a time (as in Figure 3). Why? Paper calendars showed a single month because they were limited by the size of the paper, and a month was a convenient breaking point. Computer screens are not so constrained, but they copy the mechanical-age artifact faithfully. On a computer, the calendar could easily be a continuously scrolling sequence of days, weeks, or months as shown in Figure 4, rather than a series of discrete pages, as in Figure 3. Scheduling something from April 28th to May 4th would be simple if weeks were contiguous instead of broken up by the arbitrary monthly division. Similarly, the grid pattern in digital calendars is almost always of a fixed size. Why couldn't the width of columns of days or the height of rows of weeks be adjustable like a spreadsheet? Certainly you'd want to adjust the sizes of your weekends to reflect their relative importance over your weekdays. Likewise, your vacation-week calendar would demand more space than a working week. The idioms are as well known as spreadsheets - that is to say, universal - but the mechanical-age models are so firmly set in our taxonomy that we rarely see software publishers deviate from the trajectory of the past. We have the tools, we just don't have the language. The designer of the software thought of calendars as a canonical image - one that couldn't be altered from the familiar. This calendar software often exhibits interesting new information-age features, like the ability to page instantly forward and backward months or years at a time, or to add graphic representations of holidays to the little day rectangles. These same calendars rarely break the one-month-per- screen archetype, though, and it is this one thing that really holds digital calendars back. Surprisingly, most time-management software probably handles time internally - its implementation model - as a Figure 3. The ubiquitous calendar is so familiar that we rarely stop to apply our information-age design sensibilities to it, but that old calendar was designed for small pieces of paper ; not for computer screens. The one shown here is from the Calendar in Windows 3.1 . How would you redesign it? What aspects of the calendar are artifacts of its old, mechanical-age platform? continuum, and only renders it as discrete months in its user interface - its manifest model! Sometimes people counter that the one-month-per- page calendar is better because it is familiar and unthreatening to users. I doubt it. Most people's mental models don't break time into monthly chunks, but rather see it as a continuum of days. Nor do people find it difficult to adapt to newer, simpler manifestations of familiar systems. We adapted to electric from gas stoves without a hitch. Similarly, the transition from manual transmissions to automatics, from AM radio to FM, from conventional to microwave ovens, and from vinyl records to compact discs was simple and painless. All of those paper-style calendars on various personal information managers (PIMs) and schedulers are mute testimony to how our taxonomy - our language - influences our designs. If we depend on words from the mechanical age, we will build software from the mechanical age. Better software is based on information-age thinking. It's worse on a computer We encounter another big problem when we bring our familiar mechanical-age models over to the Technical Communication, Third Quarter 1996 235</page><page sequence="8">Figure 4. Scrolling is an idiom extremely familiar to computer users . Why not add scrolling to the calendar to create a better one? This perpetual calendar can do everything the old one can, and it also solves the mechanical-age problem of scheduling things across monthly boundaries. Why drag old limitations onto new platforms just out of habit? What other improvements can you think of? computer. Simply put, mechanical-age processes are a lot worse when computerized. Procedures are easier by hand than they are with computers. Try to type someone's address on an envelope with a computer. The only time it gets easier is if you have 500 envelopes to address. Transliterated mechanical models are always worse on computers Another example, a name and address list on a computer - if it is faithfully rendered like a little bound book - will be much more complex, inconvenient, and difficult to use than the actual book. The name and address book, for example, stores names in alphabetical order by last name, but what if you want to find someone by his or her first name? The mechanical-age artifact doesn't help you: you have to scan the pages manually. So, too, does the computerized version: it can't search by first name either. The difference is that, on the computer screen, you lose many subtle visual cues offered by the paper-based book. The scrollbars and dialog boxes are harder to use, to visualize, and to understand than flipping pages. They are rocks thrown at your feet. Whenever you take a mechanical process and put it on a computer, the user of that process will suffer. The only situation where transliterated processes yield an advantage is if the sheer quantity of items to be processed is large enough to justify doing the task en masse. Early data-processing systems did this with applications like invoicing and billing. Most of our desktop computing jobs don't involve sufficiently large quantities of information for this to remain true. But there is another, bigger problem with transliterated mechanical models. The old mechanical method will always have the strengths and weaknesses of its medium, like pen and paper. Software has a completely different set of strengths and weaknesses, yet when those old models are brought across without change, they combine the weaknesses of the old with the weaknesses of the new. In our address book example, the computer could easily search for an entry by first name, but, by storing the names in the same paradigm as the mechanical artifact, we deprive ourselves of new ways of searching. We limit ourselves to not much more than what we could do in the world of paper and ink, but this time we have to do it through dialog boxes and menus. When designers rely on mechanical-age paradigms to guide them, they are blinded to the far greater potential of the computer to do information management tasks in a better, albeit different, way. Í1 236 Technical Communication , Third Quarter 1996</page></plain_text>